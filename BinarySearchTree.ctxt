#BlueJ class context
comment0.params=target
comment0.target=java.lang.Comparable\ find(java.lang.Comparable)
comment0.text=\r\n\ Starter\ method\ find.\r\n\ @pre\ The\ target\ object\ must\ implement\r\n\ \ \ \ \ \ the\ Comparable\ interface.\r\n\ @param\ target\ The\ Comparable\ object\ being\ sought\r\n\ @return\ The\ object,\ if\ found,\ otherwise\ null\r\n
comment1.params=localRoot\ target
comment1.target=java.lang.Comparable\ find(Node,\ java.lang.Comparable)
comment1.text=\r\n\ Recursive\ find\ method.\r\n\ @param\ localRoot\ The\ local\ subtree\u00C3\u00AF\u00C2\u00BF\u00C2\u00BDs\ root\r\n\ @param\ target\ The\ object\ being\ sought\r\n\ @return\ The\ object,\ if\ found,\ otherwise\ null\r\n
comment10.params=localRoot
comment10.target=int\ size(Node)
comment10.text=\r\n\ Method\ returns\ the\ size\ of\ a\ BST\ instance\ in\ terms\ of\ its\ number\ of\ nodes\r\n\ http\://stackoverflow.com/questions/5240758/binary-search-tree-using-recursion-in-java\r\n
comment2.params=item
comment2.target=boolean\ add(java.lang.Comparable)
comment2.text=\r\n\ Starter\ method\ add.\r\n\ @pre\ The\ object\ to\ insert\ must\ implement\ the\r\n\ \ \ \ \ \ Comparable\ interface.\r\n\ @param\ item\ The\ object\ being\ inserted\r\n\ @return\ true\ if\ the\ object\ is\ inserted,\ false\r\n\ \ \ \ \ \ \ \ \ if\ the\ object\ already\ exists\ in\ the\ tree\r\n
comment3.params=localRoot\ item
comment3.target=Node\ add(Node,\ java.lang.Comparable)
comment3.text=\r\n\ Recursive\ add\ method.\r\n\ @post\ The\ data\ field\ addReturn\ is\ set\ true\ if\ the\ item\ is\ added\ to\r\n\ \ \ \ \ \ \ the\ tree,\ false\ if\ the\ item\ is\ already\ in\ the\ tree.\r\n\ @param\ localRoot\ The\ local\ root\ of\ the\ subtree\r\n\ @param\ item\ The\ object\ to\ be\ inserted\r\n\ @return\ The\ new\ local\ root\ that\ now\ contains\ the\r\n\ \ \ \ \ \ \ \ \ inserted\ item\r\n
comment4.params=target
comment4.target=java.lang.Comparable\ delete(java.lang.Comparable)
comment4.text=\r\n\ Starter\ method\ delete.\r\n\ @post\ The\ object\ is\ not\ in\ the\ tree.\r\n\ @param\ target\ The\ object\ to\ be\ deleted\r\n\ @return\ The\ object\ deleted\ from\ the\ tree\r\n\ \ \ \ \ \ \ \ \ or\ null\ if\ the\ object\ was\ not\ in\ the\ tree\r\n\ @throws\ ClassCastException\ if\ target\ does\ not\ implement\r\n\ \ \ \ \ \ \ \ \ Comparable\r\n
comment5.params=localRoot\ item
comment5.target=Node\ delete(Node,\ java.lang.Comparable)
comment5.text=\r\n\ Recursive\ delete\ method.\r\n\ @post\ The\ item\ is\ not\ in\ the\ tree;\r\n\ \ \ \ \ \ \ deleteReturn\ is\ equal\ to\ the\ deleted\ item\r\n\ \ \ \ \ \ \ as\ it\ was\ stored\ in\ the\ tree\ or\ null\r\n\ \ \ \ \ \ \ if\ the\ item\ was\ not\ found.\r\n\ @param\ localRoot\ The\ root\ of\ the\ current\ subtree\r\n\ @param\ item\ The\ item\ to\ be\ deleted\r\n\ @return\ The\ modified\ local\ root\ that\ does\ not\ contain\r\n\ \ \ \ \ \ \ \ \ the\ item\r\n
comment6.params=parent
comment6.target=java.lang.Comparable\ findLargestChild(Node)
comment6.text=\r\n\ Find\ the\ node\ that\ is\ the\r\n\ inorder\ predecessor\ and\ replace\ it\r\n\ with\ its\ left\ child\ (if\ any).\r\n\ @post\ The\ inorder\ predecessor\ is\ removed\ from\ the\ tree.\r\n\ @param\ parent\ The\ parent\ of\ possible\ inorder\r\n\ \ \ \ \ \ \ \ predecessor\ (ip)\r\n\ @return\ The\ data\ in\ the\ ip\r\n
comment7.params=
comment7.target=int\ height()
comment7.text=\r\n\ starter\ height\ method\r\n
comment8.params=localRoot
comment8.target=int\ height(Node)
comment8.text=\r\n\ Method\ returns\ the\ height\ of\ a\ BST\ instance\ \ \ \ \ \r\n\ \r\n
comment9.params=
comment9.target=int\ size()
comment9.text=\r\n\ starter\ size\ mehtod\r\n
numComments=11
